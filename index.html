<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=1100, user-scalable=yes, minimum-scale=0.1, maximum-scale=5.0">
    <title>Screenplay Reader - ElevenLabs</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Courier', 'Courier New', monospace; background: #1a1a2e; color: #fff; font-size: 12pt; }
        .header { background: #0f3460; padding: 20px; text-align: center; position: sticky; top: 0; z-index: 100; }
        h1 { color: #e94560; font-size: 1.8em; font-family: 'Segoe UI', sans-serif; margin-bottom: 15px; }
        .controls { display: flex; gap: 10px; justify-content: center; align-items: center; flex-wrap: wrap; }
        .file-label, button { padding: 12px 30px; background: #e94560; border-radius: 8px; cursor: pointer; color: white; font-weight: 600; font-family: 'Segoe UI', sans-serif; border: none; font-size: 1em; }
        button:disabled { opacity: 0.4; cursor: not-allowed; }
        input[type="file"] { display: none; }
        .screenplay-page { width: 8.5in; margin: 40px auto; background: white; color: black; box-shadow: 0 0 30px rgba(0,0,0,0.5); }
        .pdf-page { min-height: 11in; padding: 1in 0; page-break-after: always; position: relative; }
        .pdf-page:not(:last-child) { border-bottom: 3px solid #1a1a2e; margin-bottom: 40px; }
        .page-number { position: absolute; top: 0.5in; right: 1in; color: #999; font-size: 10pt; font-family: 'Segoe UI', sans-serif; }
        .screenplay-line { margin-bottom: 0; line-height: 1; white-space: pre-wrap; cursor: pointer; transition: background-color 0.2s; }
        .screenplay-line:hover { background-color: rgba(233, 69, 96, 0.2); }
        .highlight { background: yellow; }
        .selected-start { background: rgba(233, 69, 96, 0.3); border-left: 4px solid #e94560; padding-left: 8px; }
        .upload-area { text-align: center; padding: 100px 20px; color: #aaa; }
        .status { position: fixed; bottom: 20px; right: 20px; background: #0f3460; padding: 15px 25px; border-radius: 10px; }
        .voice-panel { background: #16213e; padding: 15px; margin-top: 10px; border-radius: 10px; max-height: 200px; overflow-y: auto; transition: max-height 0.3s ease, margin 0.3s ease, padding 0.3s ease, opacity 0.3s ease; position: relative; }
        .voice-panel.hidden { max-height: 0; margin-top: 0; padding-top: 0; padding-bottom: 0; opacity: 0; overflow: hidden; }
        .voice-panel h3 { position: sticky; top: 0; background: #16213e; padding-bottom: 8px; z-index: 1; font-size: 1em; color: #e94560; }
        .voice-item { display: grid; grid-template-columns: 120px 1fr; gap: 10px; margin-bottom: 8px; font-size: 0.9em; }
        .voice-item label { color: #e94560; font-weight: bold; }
        .voice-item select { padding: 6px; background: #0f3460; color: white; border: 2px solid #e94560; border-radius: 5px; font-size: 0.9em; }
        .voice-toggle-btn { background: #16213e; color: #e94560; border: 2px solid #e94560; padding: 8px 20px; border-radius: 8px; }
        .voice-toggle-btn:hover { background: #e94560; color: white; }
    </style>
</head>
<body>
    <div class="header">
        <h1>üé¨ Screenplay Reader - ElevenLabs Edition</h1>
        
        <div class="controls">
            <label for="fileInput" class="file-label">üìÅ Upload PDF</label>
            <input type="file" id="fileInput" accept=".pdf">
            
            <div style="display: flex; align-items: center; gap: 10px;">
                <label style="color: white; font-family: 'Segoe UI', sans-serif;">Go to Page:</label>
                <input type="number" id="pageJump" min="1" value="1" style="width: 70px; padding: 8px; border-radius: 5px; border: 2px solid #e94560; background: #0f3460; color: white; font-size: 1em;">
                <button id="jumpBtn" disabled style="padding: 8px 20px;">Go</button>
            </div>
            
            <div style="display: flex; align-items: center; gap: 10px;">
                <label style="color: white; font-family: 'Segoe UI', sans-serif;">Speed:</label>
                <input type="range" id="speedControl" min="0.5" max="2" step="0.1" value="1" style="width: 120px;">
                <span id="speedValue" style="color: white; font-family: 'Segoe UI', sans-serif; width: 40px;">1.0x</span>
            </div>

            <div style="display: flex; align-items: center; gap: 10px;">
                <label style="color: white; font-family: 'Segoe UI', sans-serif;">Volume:</label>
                <input type="range" id="volumeControl" min="0" max="1" step="0.1" value="1" style="width: 120px;">
                <span id="volumeValue" style="color: white; font-family: 'Segoe UI', sans-serif; width: 40px;">100%</span>
            </div>
            
            <button id="playBtn" disabled>‚ñ∂Ô∏è Play</button>
            <button id="stopBtn" disabled>‚èπÔ∏è Stop</button>
            <button class="voice-toggle-btn" id="voiceToggleBtn" style="display: none;">Hide Voices ‚ñ≤</button>
        </div>

        <div class="voice-panel hidden" id="voicePanel">
            <h3 style="margin-bottom: 10px;">Voice Assignment (ElevenLabs)</h3>
            <div id="voiceContent">
                <div class="voice-item">
                    <label>Narrator:</label>
                    <select id="narratorVoice"></select>
                    <input type="range" id="narratorVolume" min="0.3" max="1.5" step="0.1" value="1.0" title="Narrator Volume">
                </div>
                <div id="characterVoices"></div>
            </div>
        </div>
    </div>

    <div id="screenplayContent">
        <div class="upload-area">
            <h2 style="color: #e94560;">ElevenLabs Screenplay Reader</h2>
            <p>Upload your screenplay PDF and click Play</p>
            <p>Click on any line to start reading from there</p>
        </div>
    </div>

    <div class="status" id="status">Loading voices...</div>

    <script>
        const API_URL = 'https://screenplay-api.vercel.app';
        
        let voices = [];
        let elements = [];
        let currentIndex = 0;
        let isPlaying = false;
        let isPaused = false;
        let characterVoiceMap = {};
        let characterVolumeMap = {}; // NEW: Store volume for each character
        let selectedStartIndex = null;
        let isJumping = false;
        let playbackSpeed = 1.0;
        let volumeLevel = 1.0;
        let currentAudio = null;
        let audioQueue = [];
        let isLoadingAudio = false;
        let abortController = null; // NEW: To cancel pending requests

        const fileInput = document.getElementById('fileInput');
        const screenplayContent = document.getElementById('screenplayContent');
        const status = document.getElementById('status');
        const playBtn = document.getElementById('playBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const stopBtn = document.getElementById('stopBtn');
        const voicePanel = document.getElementById('voicePanel');
        const narratorVoice = document.getElementById('narratorVoice');
        const narratorVolume = document.getElementById('narratorVolume');
        const characterVoices = document.getElementById('characterVoices');
        const speedControl = document.getElementById('speedControl');
        const speedValue = document.getElementById('speedValue');
        const volumeControl = document.getElementById('volumeControl');
        const volumeValue = document.getElementById('volumeValue');
        const pageJump = document.getElementById('pageJump');
        const jumpBtn = document.getElementById('jumpBtn');
        const voiceToggleBtn = document.getElementById('voiceToggleBtn');

        speedControl.addEventListener('input', (e) => {
            playbackSpeed = parseFloat(e.target.value);
            speedValue.textContent = playbackSpeed.toFixed(1) + 'x';
        });

        volumeControl.addEventListener('input', (e) => {
            volumeLevel = parseFloat(e.target.value);
            volumeValue.textContent = Math.round(volumeLevel * 100) + '%';
            if (currentAudio) {
                currentAudio.volume = volumeLevel;
            }
        });

        jumpBtn.addEventListener('click', () => {
            const pageNum = parseInt(pageJump.value);
            if (pageNum && pageNum >= 1) {
                const firstElementOnPage = elements.find(el => el.page === pageNum);
                if (firstElementOnPage) {
                    firstElementOnPage.element.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    document.querySelectorAll('.selected-start').forEach(el => el.classList.remove('selected-start'));
                    firstElementOnPage.element.classList.add('selected-start');
                    selectedStartIndex = firstElementOnPage.id;
                    status.textContent = 'Jumped to page ' + pageNum;
                }
            }
        });

        voiceToggleBtn.addEventListener('click', () => {
            voicePanel.classList.toggle('hidden');
            voiceToggleBtn.textContent = voicePanel.classList.contains('hidden') ? 'Show Voices ‚ñº' : 'Hide Voices ‚ñ≤';
        });

        async function loadVoices() {
            try {
                const response = await fetch(`${API_URL}/api/voices`);
                const data = await response.json();
                voices = data.voices;

                narratorVoice.innerHTML = '';
                voices.forEach((voice, index) => {
                    const option = document.createElement('option');
                    option.textContent = voice.name;
                    option.value = index;
                    narratorVoice.appendChild(option);
                });

                status.textContent = `Loaded ${voices.length} ElevenLabs voices!`;
            } catch (error) {
                status.textContent = 'Error loading voices';
                console.error(error);
            }
        }

        loadVoices();

        function expandAbbreviations(text) {
            const abbreviations = {
                'EXT.': 'Exterior.',
                'INT.': 'Interior.',
                'V.O.': 'voice over',
                'O.S.': 'off screen',
                'O.C.': 'off camera',
                'CONT\'D': 'continued',
                'POV': 'point of view'
            };
            let result = text;
            for (const abbr in abbreviations) {
                const regex = new RegExp(abbr.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
                result = result.replace(regex, abbreviations[abbr]);
            }
            return result;
        }

        fileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            status.textContent = 'Loading PDF...';

            try {
                await loadPDF(file);
                playBtn.disabled = false;
                jumpBtn.disabled = false;
                status.textContent = 'Ready to play';
            } catch (error) {
                console.error('Error:', error);
                status.textContent = 'Error loading PDF';
            }
        });

        async function loadPDF(file) {
            if (!window.pdfjsLib) {
                await new Promise((resolve, reject) => {
                    const script = document.createElement('script');
                    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js';
                    script.onload = () => {
                        window.pdfjsLib.GlobalWorkerOptions.workerSrc = 
                            'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
                        resolve();
                    };
                    script.onerror = reject;
                    document.head.appendChild(script);
                });
            }

            const arrayBuffer = await file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;

            const container = document.createElement('div');
            container.className = 'screenplay-page';

            elements = [];
            const characters = new Set();
            let elementId = 0;
            let lastCharacterName = null;

            for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
                const pageDiv = document.createElement('div');
                pageDiv.className = 'pdf-page';

                const pageNumber = document.createElement('div');
                pageNumber.className = 'page-number';
                pageNumber.textContent = 'Page ' + pageNum;
                pageDiv.appendChild(pageNumber);

                const pdfPage = await pdf.getPage(pageNum);
                const textContent = await pdfPage.getTextContent();

                const linesByY = {};
                textContent.items.forEach(item => {
                    const y = Math.round(item.transform[5]);
                    if (!linesByY[y]) linesByY[y] = [];
                    linesByY[y].push({ text: item.str, x: item.transform[4] });
                });

                const sortedYs = Object.keys(linesByY).sort((a, b) => b - a);

                sortedYs.forEach(y => {
                    const items = linesByY[y].sort((a, b) => a.x - b.x);
                    const lineText = items.map(item => item.text).join('').trim();
                    
                    if (lineText && !lineText.match(/^\d+\.?$/)) {
                        const leftMarginInches = items[0].x / 72;

                        const div = document.createElement('div');
                        div.className = 'screenplay-line';
                        div.style.marginLeft = leftMarginInches + 'in';
                        div.style.marginRight = '1in';
                        div.textContent = lineText;
                        pageDiv.appendChild(div);

                        const isSceneHeading = leftMarginInches < 1.5 && lineText.match(/\b(INT\.|EXT\.)/i);
                        const isCharacter = pageNum > 1 && leftMarginInches > 2.5 && leftMarginInches < 4.5 && 
                                          lineText === lineText.toUpperCase() && lineText.length < 40 && !isSceneHeading;
                        const isDialogue = leftMarginInches > 1.8 && leftMarginInches < 3.2 && lastCharacterName !== null;

                        if (isCharacter) {
                            lastCharacterName = lineText.replace(/\s*\(.*?\)\s*/g, '').trim();
                            characters.add(lastCharacterName);
                        } else if (!isDialogue) {
                            lastCharacterName = null;
                        }

                        elements.push({
                            id: elementId,
                            text: lineText,
                            element: div,
                            character: isDialogue ? lastCharacterName : null,
                            isCharacter: isCharacter,
                            isDialogue: isDialogue,
                            isSceneHeading: isSceneHeading,
                            page: pageNum
                        });

                        (function(capturedId) {
                            div.addEventListener('click', () => {
                                document.querySelectorAll('.selected-start').forEach(el => el.classList.remove('selected-start'));
                                div.classList.add('selected-start');
                                selectedStartIndex = capturedId;
                                status.textContent = 'Start position set';
                                
                                if (isPlaying) {
                                    console.log('USER CLICKED NEW LINE - FORCE STOP ALL AUDIO');
                                    isJumping = true;
                                    isPaused = false;
                                    pauseBtn.textContent = '‚è∏Ô∏è Pause';
                                    
                                    // NUCLEAR OPTION: Stop everything
                                    if (abortController) {
                                        abortController.abort();
                                        abortController = null;
                                    }
                                    if (currentAudio) {
                                        currentAudio.pause();
                                        currentAudio.src = '';
                                        currentAudio = null;
                                    }
                                    audioQueue = [];
                                    isLoadingAudio = false;
                                    
                                    const foundIndex = elements.findIndex(el => el.id === capturedId);
                                    currentIndex = foundIndex >= 0 ? foundIndex : 0;
                                    
                                    // Wait a bit longer to ensure everything stopped
                                    setTimeout(() => {
                                        console.log('Restarting from new position');
                                        isJumping = false;
                                        readNext();
                                    }, 200);
                                }
                            });
                        })(elementId);

                        elementId++;
                    }
                });

                container.appendChild(pageDiv);
            }

            pageJump.max = pdf.numPages;
            screenplayContent.innerHTML = '';
            screenplayContent.appendChild(container);
            buildCharacterVoices(Array.from(characters));
        }

        function buildCharacterVoices(characters) {
            characterVoices.innerHTML = '';
            if (characters.length === 0) return;

            voicePanel.classList.remove('hidden');
            voiceToggleBtn.style.display = 'inline-block';
            voiceToggleBtn.textContent = 'Hide Voices ‚ñ≤';
            
            characters.forEach((character, index) => {
                const div = document.createElement('div');
                div.className = 'voice-item';

                const label = document.createElement('label');
                label.textContent = character + ':';

                const select = document.createElement('select');
                voices.forEach((voice, vIndex) => {
                    const option = document.createElement('option');
                    option.textContent = voice.name;
                    option.value = vIndex;
                    select.appendChild(option);
                });

                if (index < voices.length) select.value = (index + 1) % voices.length;
                select.addEventListener('change', () => {
                    characterVoiceMap[character] = parseInt(select.value);
                });
                characterVoiceMap[character] = parseInt(select.value);

                // Add volume slider for this character
                const volumeSlider = document.createElement('input');
                volumeSlider.type = 'range';
                volumeSlider.min = '0.3';
                volumeSlider.max = '1.5';
                volumeSlider.step = '0.1';
                volumeSlider.value = '1.0';
                volumeSlider.title = character + ' Volume';
                volumeSlider.addEventListener('input', (e) => {
                    characterVolumeMap[character] = parseFloat(e.target.value);
                });
                characterVolumeMap[character] = 1.0;

                div.appendChild(label);
                div.appendChild(select);
                div.appendChild(volumeSlider);
                characterVoices.appendChild(div);
            });
        }

        playBtn.addEventListener('click', () => {
            if (isPaused) {
                isPaused = false;
                pauseBtn.textContent = '‚è∏Ô∏è Pause';
                if (currentAudio) currentAudio.play();
                status.textContent = 'Playing...';
            } else if (!isPlaying) {
                startReading();
            }
        });

        pauseBtn.addEventListener('click', () => {
            if (isPlaying && !isPaused) {
                isPaused = true;
                pauseBtn.textContent = '‚ñ∂Ô∏è Resume';
                if (currentAudio) currentAudio.pause();
                status.textContent = 'Paused';
            } else if (isPaused) {
                isPaused = false;
                pauseBtn.textContent = '‚è∏Ô∏è Pause';
                if (currentAudio) currentAudio.play();
                status.textContent = 'Playing...';
            }
        });

        stopBtn.addEventListener('click', () => stopReading());

        function startReading() {
            console.log('START READING - CLEARING ALL AUDIO');
            
            // Nuclear option: stop everything
            if (abortController) {
                abortController.abort();
                abortController = null;
            }
            if (currentAudio) {
                currentAudio.pause();
                currentAudio.src = '';
                currentAudio = null;
            }
            audioQueue = [];
            isLoadingAudio = false;
            
            if (selectedStartIndex !== null) {
                const foundIndex = elements.findIndex(el => el.id === selectedStartIndex);
                currentIndex = foundIndex >= 0 ? foundIndex : 0;
            } else {
                currentIndex = 0;
            }
            
            isPlaying = true;
            isPaused = false;
            playBtn.disabled = true;
            pauseBtn.disabled = false;
            stopBtn.disabled = false;
            pauseBtn.textContent = '‚è∏Ô∏è Pause';
            status.textContent = 'Starting...';
            
            setTimeout(() => readNext(), 150);
        }

        function readNext() {
            if (!isPlaying || currentIndex >= elements.length || isPaused || isLoadingAudio) {
                if (currentIndex >= elements.length && !isLoadingAudio) stopReading();
                return;
            }

            const element = elements[currentIndex];
            currentIndex++;

            document.querySelectorAll('.highlight').forEach(el => el.classList.remove('highlight'));
            element.element.classList.add('highlight');
            element.element.scrollIntoView({ behavior: 'smooth', block: 'center' });
            status.textContent = 'Reading: ' + currentIndex + '/' + elements.length;

            if (element.isCharacter) {
                readNext();
                return;
            }

            let fullText = element.text;
            let nextIndex = currentIndex;
            
            if (element.isDialogue) {
                while (nextIndex < elements.length) {
                    const nextElement = elements[nextIndex];
                    if (nextElement.isSceneHeading) break;
                    if (nextElement.isDialogue && nextElement.character === element.character) {
                        fullText += ' ' + nextElement.text;
                        nextElement.element.classList.add('highlight');
                        nextIndex++;
                        currentIndex = nextIndex;
                    } else break;
                }
            } else {
                const baseIndent = element.element.style.marginLeft;
                while (nextIndex < elements.length) {
                    const nextElement = elements[nextIndex];
                    if (nextElement.isSceneHeading || nextElement.isDialogue || nextElement.isCharacter) break;
                    const nextIndent = parseFloat(nextElement.element.style.marginLeft) || 0;
                    const baseIndentVal = parseFloat(baseIndent) || 0;
                    if (Math.abs(nextIndent - baseIndentVal) > 0.5) break;
                    fullText += ' ' + nextElement.text;
                    nextElement.element.classList.add('highlight');
                    nextIndex++;
                    currentIndex = nextIndex;
                }
            }

            const spokenText = expandAbbreviations(fullText);
            let voiceIndex = parseInt(narratorVoice.value) || 0;
            let characterVolume = parseFloat(narratorVolume.value) || 1.0;
            
            if (element.isDialogue && element.character && characterVoiceMap[element.character] !== undefined) {
                voiceIndex = characterVoiceMap[element.character];
                characterVolume = characterVolumeMap[element.character] || 1.0;
            }

            speakText(spokenText, voiceIndex, characterVolume);
        }

        async function speakText(text, voiceIndex, characterVolume) {
            if (!text || text.trim() === '') {
                readNext();
                return;
            }

            // Prevent multiple simultaneous audio loads
            if (isLoadingAudio) return;
            isLoadingAudio = true;

            try {
                const voice = voices[voiceIndex];
                const response = await fetch(`${API_URL}/api/synthesize`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        text: text,
                        voice_id: voice.voice_id,
                        speed: Math.min(playbackSpeed, 1.2) // ElevenLabs max is 1.2
                    })
                });

                if (!response.ok) throw new Error('Failed to generate speech');

                const audioBlob = await response.blob();
                const audioUrl = URL.createObjectURL(audioBlob);
                
                // Check if we're still supposed to be playing
                if (!isPlaying || isJumping) {
                    URL.revokeObjectURL(audioUrl);
                    isLoadingAudio = false;
                    return;
                }
                
                currentAudio = new Audio(audioUrl);

                currentAudio.onended = () => {
                    URL.revokeObjectURL(audioUrl);
                    currentAudio = null;
                    isLoadingAudio = false;
                    if (!isJumping && isPlaying && !isPaused) {
                        readNext();
                    }
                };

                currentAudio.onerror = () => {
                    URL.revokeObjectURL(audioUrl);
                    currentAudio = null;
                    isLoadingAudio = false;
                    if (!isJumping && isPlaying && !isPaused) {
                        readNext();
                    }
                };

                if (!isPaused && isPlaying) {
                    const playPromise = currentAudio.play();
                    if (playPromise !== undefined) {
                        playPromise.then(() => {
                            isLoadingAudio = false;
                        }).catch(error => {
                            console.error('Play failed:', error);
                            isLoadingAudio = false;
                            if (isPlaying && !isPaused) {
                                readNext();
                            }
                        });
                    } else {
                        isLoadingAudio = false;
                    }
                } else {
                    isLoadingAudio = false;
                }
            } catch (error) {
                console.error('Error:', error);
                status.textContent = 'Error generating speech';
                isLoadingAudio = false;
                if (isPlaying && !isPaused && !isJumping) {
                    readNext();
                }
            }
        }

        function stopReading() {
            console.log('STOP READING - NUCLEAR SHUTDOWN');
            
            // Abort any pending requests
            if (abortController) {
                abortController.abort();
                abortController = null;
            }
            
            if (currentAudio) {
                currentAudio.pause();
                currentAudio.src = '';
                currentAudio = null;
            }
            audioQueue = [];
            isLoadingAudio = false;
            isPlaying = false;
            isPaused = false;
            currentIndex = 0;

            document.querySelectorAll('.highlight').forEach(el => el.classList.remove('highlight'));
            playBtn.disabled = false;
            pauseBtn.disabled = true;
            stopBtn.disabled = true;
            pauseBtn.textContent = '‚è∏Ô∏è Pause';
            status.textContent = 'Stopped';
        }
    </script>
</body>
</html>
